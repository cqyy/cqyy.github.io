---
layout: post
title: Bigtable
description: "Bigtable:A distributed storage system for structured data"
modified: 2014-10-26
tags: [数据库]
imagefeature: cs-9.jpg
category: DataBase
comments: true
share: true
---

Paper:《<a href="http://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf">Bigtable: A Distributed Storage System for Structured Data</a>》


## 1.Overview

BigTable是由Google设计实现的分布式非关系数据库，可管理PB级别的数据，包含上千台服务器组成的集群。Bigtable提供了灵活、高性能的结构化数据存储服务。

## 2.Data Model

Bigtable可以简单的理解为一个 稀疏、分布式、持久、多版本的有序Map。该Map通过row key,column key,timestamp进行索引，值为任意的byte数组。

>（row key,column key,timestamp） => string

###2.1 Rows

Row key为任意字符串，并按字典顺序进行排序。在单一row key下的读或写操作都是原子的。

对于一个表，Bigtable根据row key的范围进行分片，每片叫***`tablet`***，这是进行负载均衡和任务分配的基本单位（类似于GFS中的Block，但该分片为逻辑意义）。因此，同一范围的数据将存储在相近的位置，小范围数据的读取也将非常有效，因为只需要和很少的机器通信。

应用也可以利用该特性来提高应用性能，Google内部的Webtable就是一个例子：Webtable存储各种网页的内容和元数据，其将row key设置为该网页网址的逆序（和java包命名规则一样），使得url相近的web内容存储在相近的位置。

###2.2 Column Families

Column family是指将相关的数据组成一组，使得在分布式存储的情况下，可以更高效的访问数据。Bigtable中，Column family为最基本的访问控制单元。

传统情况下，数据以表形式进行存储，应用的任何数据访问都将读取表中的完整行，即包含读取行的所有列信息。对于Bigtable应用场景中，每个表所包含的列数量将比较巨大，而应用读取数据绝大部分情况下只是对其中的某一部分感兴趣，若读取所用行数据则效率低下。通过Column Family方式，将列按数据的逻辑属性进行分类（分类由应用完成），不同分类的数据分别存储，使得在读取的时候，可以仅仅读取部分列数据提高效率。

Bigtable中，Column family中的数据通常为同一属性，并且必须在插入数据前创建，通过如下语法创建：*family:qualifier*。


###2.3 Bigtable vs. Relational DataModels

<figure><img src="/images/bigtable/datamodel.png"/></figure>

传统关系数据库模型中，学生选课关系通过三个表进行存储，表之间通过主键与外键建立联系。
而在Bigtable模型中，分别以学生ID和课程ID建立两个表进行存储。可以看到学生有两个Column Family：info和course。如此，访问学生个人信息只需要读取info这Column Family即可。

##3.数据存储

Bigtable数据存储构建在GFS上，在GFS上的物理块单位为***`SSTable`***。SSTable提供了持久的、有序不可变的key到value的映射。SSTable比较大，在读取和查找数据上效率低下，所以其内部有分为一系列的block（一般为64k大小）。在每个SSTable末尾存储该数据块的索引，当打开该块时，索引将被加载到内存中，是的数据查找只需要一次磁盘访问：首先通过二分查找在内存索引中找到合适的块，然后从磁盘读取该块。并且，SSTable可以完全的映射到内存（一般100~200MB），使得可以高效的执行lookup或scan操作。

Bigtable本身是一个share-nothing架构，对于系统关键性的数据，它将其存储到Chubby中。Chubby是一个分布式、高可用、持久化分布式锁服务，有五个active replicas组成，使用Paxos算法。Bigtable使用Chubby完成如下任务：

- 1 保证任何时刻最多有一个active master
- 2.存储Bigtable数据的引导位置
- 3.发现tablet server以及停止tablet server
- 4.存储Bigtable模式信息（各表的column family信息）
- 5.存储访问控制列表

##4.实现

Bigtable主要由三部分组成：1.一个Master server，多个Tablet Server以及一个连接所有客户端的字典。

Master负责分配tablet给Tablet Server,检测Tablet Server的增加和超时，对Tablet Server进行负载均衡，以及Bigtable在GFS上的垃圾数据回收。

Tablet Server管理具体的tablet，处理数据的读写以及当tablet过大时，进行分割。

与GFS不同，Client不需要访问Master就可以直接读取数据。

###4.1 Tablet Location


<figure><img src="/images/bigtable/tabletlocation.png"/></figure>

Bigtable的数据存储使用三级结构。首先是存储在Chubby中的`root tablet`的位置信息，然后是`root tablet`，它指定了二级的元数据信息，二级元数据信息才真正连接到实际的数据中。

在METADATA中，存储了各tablet的位置，每个tablet一条，包含器所属table的标识符以及其最后一行数据的row key。每一条占1kb。若假设METADATA tablets最大为128MB，在该三级结构最大支持2^{34}个tablet.

Client将缓存tablet位置信息。若Client不知道tablet的位置或者缓存的位置信息不正确，它将会递归的寻找tablet的位置。

###4.2 Tablet Assignment

Bigtable中，Master或Tablet Server都可能崩溃，为了实现高可用性，系统的关键元数据都存储在Chubby中。

任何Tablet在任何时间最多被分配给一个Tablet Server，Master追踪Tablet Server状态以及各个Tablet Server当前的tablet分配情况。当发现有未分配的tablet且存在有足够空间分配tablet的Tablet Server时，Master将通过请求将该tablet分配出去。

Bigtable使用Chubby来追踪当前集群状况。当Tablet Server启动时，它将在Chubby一个特定的目录下创建一个唯一的文件，并对此文件上互斥锁。Master通过检测该目录下文件的加锁状况即可知道当前集群各Tablet Server的运行状况。Tablet Server发现其失去互斥锁时将停止服务，若其发现锁文件还存在，则会尝试对其重新加锁，若文件不存在，则表示Master要求其关闭，它将停止服务并退出。

